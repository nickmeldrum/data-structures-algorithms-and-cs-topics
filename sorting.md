# Sorting

classifications:

## 'elementary' sorts:

mostly (except insertion) bad sorts only used for educational purposes:

worst case complexity: O(n^2)

bubble, selection, insertion:

### bubblesort:

the algorithm:

 > iterate through list swapping adjacent items to the correct order. Continue iterating until there were no swaps in a pass through.

 * classication: comparison, exchanging, in place, stable
 * best: O(n), average: O(n^2), worst: O(n^2)
 * size: O(1)
 * usages: none. purely educational.

### selection sort:

the algorithm:

 > 

 * classication: 
 * best: 
 * size: 
 * usages: 

### insertion sort:

the algorithm:

 > 

 * classication: 
 * best: 
 * size: 
 * usages: 


## efficient sorts:

use "divide and conquer" or "partitioning" to achieve n log n complexity:

merge, quick, heap:


### mergesort:


### quicksort:


### heapsort:



## non-comparison sorts:

Note: all above are comparison sorts (where you compare a node to all the other nodes) and are therefore limited to a complexity of at least log n

radix, counting:

stable

comparison sort
